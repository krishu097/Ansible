---
# Ensure eksctl exists (fail early with a clear error)
- name: Verify eksctl is installed
  command: bash -lc "command -v eksctl"
  register: _eksctl_check
  changed_when: false
  failed_when: _eksctl_check.rc != 0

# --- VPC discovery ---
- name: Discover VPC details by tag
  amazon.aws.ec2_vpc_net_info:
    region: "{{ aws_region }}"
    filters:
      "tag:Environment": "{{ env_name }}"
      "tag:ManagedBy": "ansible"
  register: vpc_info

- name: Fail if VPC not found
  fail:
    msg: "No VPC found with Environment={{ env_name }} ManagedBy=ansible"
  when: vpc_info.vpcs | length == 0

- name: Set VPC ID
  set_fact:
    vpc_id: "{{ vpc_info.vpcs[0].id }}"

# --- Subnet discovery: robust & self-healing ---

# 1) Try Tier=private
- name: Discover private subnets by tag (Tier=private)
  amazon.aws.ec2_vpc_subnet_info:
    region: "{{ aws_region }}"
    filters:
      vpc-id: "{{ vpc_id }}"
      "tag:Tier": "private"
  register: subnet_info_tier

# 2) If not enough, try Type=private
- name: Discover private subnets by tag (Type=private) as fallback
  amazon.aws.ec2_vpc_subnet_info:
    region: "{{ aws_region }}"
    filters:
      vpc-id: "{{ vpc_id }}"
      "tag:Type": "private"
  register: subnet_info_type
  when: subnet_info_tier.subnets | default([]) | length < 2

# 3) If still not enough, fetch all subnets then filter by attribute
- name: Discover ALL subnets in VPC (final fallback)
  amazon.aws.ec2_vpc_subnet_info:
    region: "{{ aws_region }}"
    filters:
      vpc-id: "{{ vpc_id }}"
  register: subnet_info_all
  when: (subnet_info_tier.subnets | default([]) | length < 2) and
    (subnet_info_type.subnets | default([]) | length < 2)

# 4) Choose best subnet source + mark if we used 'ALL'
- name: Choose best subnet list source
  set_fact:
    _subnets_raw: >-
      {{
        (subnet_info_tier.subnets)
          if (subnet_info_tier.subnets | default([]) | length) >= 2 else
        (subnet_info_type.subnets | default([]))
          if (subnet_info_type is defined and (subnet_info_type.subnets | default([]) | length) >= 2) else
        (subnet_info_all.subnets | default([]))
      }}
    _used_all: >-
      {{
        (subnet_info_all is defined)
        and (subnet_info_tier.subnets | default([]) | length < 2)
        and (subnet_info_type.subnets | default([]) | length < 2)
      }}

# 5) If we used the ALL list, filter to private: map_public_ip_on_launch == false
- name: Filter ALL subnets down to private (attribute-based)
  set_fact:
    _subnets_private_attr: "{{ _subnets_raw | selectattr('map_public_ip_on_launch', 'equalto', false) | list }}"
  when: _used_all | bool

- name: Finalize candidate private subnets list
  set_fact:
    _candidates: "{{ _subnets_private_attr | default(_subnets_raw) }}"

# 6) Extract az/id, uniq by AZ, sort, and take max 2
- name: Normalize and take 2 private subnets (one per AZ if possible)
  set_fact:
    private_subnets: >-
      {{
        (
          _candidates
          | json_query('[].{az: availability_zone, id: id}')
          | unique(attribute='az')
          | sort(attribute='az')
        )[:2]
      }}

# 7) Helpful debug so you can see what was found
- name: Debug discovered subnets (raw & final)
  debug:
    msg:
      - "Tier=private count: {{ subnet_info_tier.subnets | default([]) | length }}"
      - "Type=private count: {{ (subnet_info_type.subnets | default([])) | length if subnet_info_type is defined else 'n/a' }}"
      - "All subnets count: {{ (subnet_info_all.subnets | default([])) | length if subnet_info_all is defined else 'n/a' }}"
      - "Final private_subnets (max 2): {{ private_subnets }}"

# --- Security groups discovery (in same VPC) ---
- name: Lookup Control Plane SG by name
  amazon.aws.ec2_security_group_info:
    region: "{{ aws_region }}"
    filters:
      group-name: "{{ eks_controlplane_sg_name }}"
      vpc-id: "{{ vpc_id }}"
  register: cp_sg_info

- name: Lookup Worker Nodes SG by name
  amazon.aws.ec2_security_group_info:
    region: "{{ aws_region }}"
    filters:
      group-name: "{{ eks_workernodes_sg_name }}"
      vpc-id: "{{ vpc_id }}"
  register: wn_sg_info

- name: Fail if SGs not found
  fail:
    msg: "Missing SG(s): controlplane={{ eks_controlplane_sg_name }} or workernodes={{ eks_workernodes_sg_name }} in VPC {{ vpc_id }}"
  when: (cp_sg_info.security_groups | length == 0) or (wn_sg_info.security_groups | length == 0)

- name: Set SG IDs as facts
  set_fact:
    eks_controlplane_sg_id: "{{ cp_sg_info.security_groups[0].group_id }}"
    eks_workernodes_sg_id: "{{ wn_sg_info.security_groups[0].group_id }}"

# --- Nodegroup IAM role discovery ---
- name: Read nodegroup role
  amazon.aws.iam_role_info:
    name: "{{ eks_nodegroup_role_name }}"
  register: eks_nodegroup_role_info

- name: Fail if nodegroup role not found
  fail:
    msg: "Nodegroup role '{{ eks_nodegroup_role_name }}' not found."
  when: eks_nodegroup_role_info.iam_roles | length == 0

- name: Set nodegroup role ARN
  set_fact:
    eks_nodegroup_role_arn: "{{ eks_nodegroup_role_info.iam_roles[0].arn }}"

# --- Helper vars for template ---
- name: Derive nodegroup_instance_type for template
  set_fact:
    nodegroup_instance_type: "{{ (nodegroup_instance_types | first) | default('t3.medium') }}"

# --- Guardrails before rendering ---
- name: Assert inputs for eksctl
  assert:
    that:
      - private_subnets is defined
      - private_subnets | length >= 2
      - eks_workernodes_sg_id is defined
      - eks_nodegroup_role_arn is defined
    fail_msg: "Missing inputs for eksctl template (need 2 private subnets, worker SG id, nodegroup role ARN)."

# --- Render eksctl config ---
- name: Render eksctl cluster config
  template:
    src: eksctl-cluster.yaml.j2
    dest: "{{ playbook_dir }}/eksctl-cluster.yaml"

# --- Create cluster via eksctl (idempotent) ---
- name: Run eksctl to create EKS cluster
  command: eksctl create cluster -f "{{ playbook_dir }}/eksctl-cluster.yaml"
  register: eksctl_output
  changed_when: >
    ('will create' in (eksctl_output.stdout | default(''))) or
    ('created' in (eksctl_output.stdout | default('')))
  failed_when: >
    (eksctl_output.rc != 0) and
    ('already exists' not in (eksctl_output.stdout | default(''))) and
    ('already exists' not in (eksctl_output.stderr | default('')))

- name: Show eksctl output (last 4000 chars)
  debug:
    msg: "{{ (eksctl_output.stdout | default(''))[-4000:] }}"
